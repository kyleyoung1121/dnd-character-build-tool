import{c as v}from"./DANXc4Na.js";function A(t,i={},y){v.update(r=>{r._provenance?.[t]&&(r=_(r,t));const u={},c={};for(const[l,f]of Object.entries(i)){const o=l,e=r[o];Array.isArray(e)&&Array.isArray(f)?r[o]=[...e,...f]:(u[o]=e,r[o]=f)}if(y)for(const[l,f]of Object.entries(y)){const o=l,e=r[o];c[o]=e;const n=Number(f)||0,s=typeof e=="number"?e:0;r[o]=s+n}return r._provenance??={},r._provenance[t]={_set:Object.keys(i).length?i:null,_prevScalars:Object.keys(u).length?u:null,_mods:y&&Object.keys(y).length?y:null,_modsPrev:Object.keys(c).length?c:null},r})}function _(t,i){const y=t._provenance?.[i];if(!y)return t;if(!("_set"in y)&&!("_mods"in y)){const o=t._provenance;for(const[e,n]of Object.entries(y)){const s=e;Array.isArray(t[s])&&Array.isArray(n)?t[s]=a(t[s],n,i,e,o):t[s]=Array.isArray(n)?[]:null}return delete t._provenance?.[i],t}const{_set:r,_prevScalars:u,_mods:c,_modsPrev:l}=y,f=t._provenance;if(r)for(const[o,e]of Object.entries(r)){const n=o;if(Array.isArray(e))t[n]=a(t[n],e,i,o,f);else{const s=u?.[n];t[n]=s??null}}if(c)for(const o of Object.keys(c)){const e=o;if(l&&Object.prototype.hasOwnProperty.call(l,e))t[e]=l[e];else{const n=Number(c[o])||0,s=t[e],p=typeof s=="number"?s:0;t[e]=p-n}}return delete t._provenance?.[i],t}function a(t,i,y,r,u){if(!u)return t.filter(e=>!i.includes(e));const c={};for(const[e,n]of Object.entries(u)){const s="_set"in n&&n._set?n._set:n;if(!(!s||!Array.isArray(s[r])))for(const p of s[r])c[p]||(c[p]={}),c[p][e]=(c[p][e]||0)+1}const l={};for(const e of i){const n=c[e]||{};l[e]=n[y]||0}const f=[],o={};for(const e of t)if(i.includes(e)){const n=l[e]||0,s=o[e]||0;s<n?o[e]=s+1:f.push(e)}else f.push(e);return f}export{A as a,_ as r};
